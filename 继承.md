## 继承（上）

#### 访问修饰符

```java
private: 只允许在本类中访问
public: 允许在任意位置访问
protected：允许在拥有继承关系的子类里访问，或者同包非子类里访问。
默认：同包子类、同包非子类类允许调用，当前类允许调用，跨包子类不允许调用。       
```

#### 方法重写

```java
* 1、有继承关系的子类中(子类重写父类的方法)
* 2、方法名相同，参数列表相同(参数顺序、个数、类型),方法返回值相同【在方法重写中，方法的访问修饰符是可以允许有变化的】
* 3、访问修饰符，当子类进行方法重写时访问修饰符是允许改变的，但是重写访问修饰访问范围需要大于或等于父类的访问范围
* 4、与方法的参数名无关       
```

#### 方法重载

```java
方法重载：
1.有继承关系的子类中
2、方法名相同，参数列表（参数顺序、个数、类型）不同
3、方法返回值、访问修饰符任意
4、与方法的参数名无关

方法重写
1、有继承关系的子类中
2、方法名相同、参数列表相同（参数顺序、个数、类型），方法返回值相同(向下兼容，可以是父类也可以是子类)
3、访问修饰符需要大于等于父类的访问范围
4、与方法的参数名无关       
```

#### super关键字

```java
super关键字

super.name
super.eat()
super 可以调用父类所允许派生类的所有可以访问的属性和方法

子类内如果没有重写方法，可以直接调用父类方法；
子类内如果有父类重写方法，想调用父类的必须要用super.；
子类继承了父类的属性和方法，super可以引用父类一切公开属性和成员方法；
父类的构造方法不允许被继承和重写的；
```

#### 继承的初始化顺序

```java
在满足继承的条件下，继承后的初始化顺序： 
    父类：Animal 子类：Cat extends Animal 
    如果执行：Cat c = new Cat()，则加载顺序如下，我理解是分两个步骤： 
    步骤1：Cat c，声明实例：此时是加载类的过程，静态成员会被加载：     父类静态成员，如父类的静态属性和静态代码块，两者的执行优先级是一样的，先出现先执行； 
    子类静态成员，如子类的静态属性和静态代码块，两者的执行优先级是一样的，先出现先执行。 
    步骤2：new Cat()，初始化实例： 
    父类对象的构造，如父类的普通属性的初始化，构造代码块和构造方法（构造代码块先于构造方法执行）； 
    子类对象的构造，如子类的普通属性的初始化，构造代码块和构造方法（构造代码块先于构造方法执行）。
```

#### super关键字(2)

```java
super
1.代表父类引用
-访问父类成员方法：super.print();
-访问父类属性：super.name;
-访问父类构造方法:super()；
2.可以通过super（）调用父类允许被访问的其他构造方法
3.super（） 必须被放在子类构造方法中的有效代码第一行

注意：
1、子类的构造的过程中必须调用其父类的构造的方法
2、如果子类的构造方法中没有显式标注，则系统默认调用父类无参的构造方法
3、如果子类构造方法中既没有显式标注，且父类中没有无参的构造方法，则编译出错。
4、使用super调用父类指定构造方法，必须在子类的构造方法的第一行
5、父类的构造不允许被继承不允许被重写。       
```

#### this  and  super

```java
this和super区别

this：访问当前对象
super：访问父类对象

this：一个类中,可以通过this关键字来去调用当前类型中允许被访问属性和 method
super：调用父类中允许被访问属性和method

this:不能在静态关键字上下文中使用（this:代表某个对象，static代表这个类）
super:不能在静态关键上下文中字使用

this()和super()在构造函数中一山不容二虎，因为都要占用第一行，所以只能执行一个       
```

## 继承（下）

#### object类

```java
1、Object类是所有类的父类
2、一个类没有使用extends关键字明确标识继承关系，则默认继承Object类（包括数组）
3、Java中的每个类都可以使用Object中定义的方法
```

#### final关键字

```java
1. 被final修饰的类不允许被继承；
2. 被final修饰的方法不允许被重写；
3. 被final修饰的局部变量和成员属性初始化后不允许被修改；
4. 被final修饰的成员属性初始化方法：
    a. 定义时直接初始化；
    b. 在构造代码块中初始化；
    c. 在构造方法中初始化；
5. 被final修饰的变量如果是基本类型变量，初始赋值后不能被更改；如果是引用类型的变量，初始化之后不能再指向另一个对象，但对象的内容还是可变的；
6. final不允许修饰构造方法；
7. final和与static可配合使用，定义全局的不可变的方法或变量。
```

#### 注解

```java
注解：@Override
    -可以在生命包，类，属性，方法，局部变量，方法参数等的前面，用来对这些元素进行说明
    =按照运行机制分
    -源码注解：注解只在源码中存在，编译成.class文件就不存在了。
    -编译时注解：注解在源码和.class文件中都存在。
    -运行时注解:在运行阶段还起作用，甚至会影响运行逻辑的注解。
        例如Spring注解：@Autowired；
```