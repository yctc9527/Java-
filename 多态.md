#### 多态概念

```Java
多态：意味着允许不同类的对象对同一消息做出不同的响应
分类：
1）编译时多态（也叫设计时多态，举例如方法重载）
2）运行时多态（程序运行时决定调用哪个方法）       
```

```java
可以通过super关键字调用父类带参的构造方法赋值，如super(name,month);
也可以通过this关键字访问setName,setMonth进行赋值，如
this.setName(name);
this.setMonth(month);       
```

#### 向上转型

```java
向上转型，又叫隐式转型、自动转型
是子类转型为父类，小类转型为大类这种式的名称
例子：Animal two=new Cat()
父类引用指向子类实例。
可以调用子类重写父类的方法以及父类派生的方法，
但是无法调用子类独有方法！  
```

#### 向下转型

```java
向下转型也叫强制类型转换
*子类引用指向父类对象，此处必须进行强转，可以调用子类特有的方法
*必须满足转型条件才能进行强转
Animal two = new Cat();
Cat temp = (Cat)two；是正确的的，向下类型转换。相当于子类对象的还原       
```

#### 转型总结

```java
在父类当中使用static 关键字修饰的方法不能被子类所重写。加上注解会报错。
父类引用指向子类实例，可以调用子类重写的方法以及父类派生的方法，无法调用子类独有的方法。
注意：父类中的静态方法无法被子类重写，所以向上转型之后，只能调用到父类原有的静态方法。
    Animal two = new Cat();//向上转型
	two.say();//此时无法调用子类的静态方法
	Cat cat = (Cat)two;//向下转型
	cat.say();//此时可调用子类静态方法
简单来说：是谁的对象调用谁的方法.
```

#### 类型转换案例



```java
public void feed(Animal obj) {
		if(obj instanceof Cat) {
			Cat temp=(Cat)obj;
			temp.eat();
			temp.playball();
		}else if(obj instanceof Dog) {
			Dog temp=(Dog)obj;
			temp.eat();
			temp.sleep();
		}
	}   
    /*用一个方法传参的时候先向上转化成父类， 然后再根据实际情况进行判断后，转化成原来的类型 ，在调用自己本身的方法 （向下转型）*/ 
```

#### instanceof

```java
A instanceof B判断对象A是否为B类的实例，或者对象A是否有B类的特征
（如父类Animal，子类Cat，
Animal one=new Cat(); 
则one既有Cat类特征又有Animal类特征，
同理one还有Object类特征）
```

#### abstract抽象类

```java
抽象数据类型： 在类的定义前加上 abstract 关键字，使得该类成为一个抽象类
抽象类不允许被实例化，但是可以通过向上转型，指向子类实例
public 与 abstract 可以互换，但是却不能 与class关键字相互换位。

应用场景：
某个父类只是直到其子类应该包含怎样的方法，但无法准确直到这些子类如何实现这些方法

优点：
抽象类利用子类与父类的继承关系，既限制了子类的设计随意性，又避免了父类无意义的实例化       
```

#### 抽象方法

```java
抽象类：不允许被实例化
抽象方法：不允许包含方法体；子类中需要重写父类的抽象方法；否则子类也是抽象类
应用场景：
某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法
使用规则：
       1、abstract定义抽象类
       2、抽象类不能直接实例化，只能被继承，可以通过向上转型完成对象实例
       3、abstract定义抽象方法，不需要具体实现
       4、包含抽象方法的类一定是抽象类
       5、抽象类中可以没有抽象方法
       6、当一个类包含抽象方法的时候，这个类的子类一定要重写抽象方法，如果这个子类没有重写抽象方法的时候，要把这个类变成抽象类
       7、static、final、private不能与abstract并存
1. 子类的设计随意性：在不同的子类中存在相同功能的方法，但方法名、参数返回类型都不一样，但实现效果是一样的，实例化不同子类对象实现同一个的功能，则需要调用不同的方法，代码可读性不高。
2. 而抽象类可以作为子类的模板，规定方法名称、参数，返回值从而避免了子类设计的随意性。
```

#### 接口

```java 
1、接口和类分开理解！“接口不是类，而是对类的一组需求描述。”出自书《Java核心技术 卷1》的214页。
2、接口是作为一种规范，它只能在类中实现，而不能直接实例化哦！
    
接口类：
1、创建时右键包名选class下面那个，或者把类的class改成interface
2、接口类的方法没有方法体
3、使用implements 来继承接口类
public class Camera implements IPhoto{}
4、如果一个类调用了接口类，那就必须实现重写接口类中的方法（特性类似于抽象方法）
5、如果是使用接口类创建对象，用含有接口类方法的类来实例化对象
IPhoto ip=new FourthPhone();
那么就只能调用重写接口类方法的那个方法；（特性类似于向上转型）
注意：只能用含有接口类方法的类来实例化对象，而且接口类本身不能创建对象（特性类似于抽象类）
```

##### 接口成员-抽象方法&常量     

```java
接口访问修饰符：public 默认
接口当中抽象方法可以不写abstract关键字；
访问修饰符：默认public
当一个类实现接口的时候，需要去实现接口中的所有抽象方法，否侧需要将该类设置为抽象类
接口中可以包含常量，默认public static final
接口名.常量 去访问接口中的常量       
```

##### 接口成员-默认方法&静态方法

```java
default关键字：默认方法，可以带方法体；
default void connect（）{ 
    System.out.println("我是接口中的默认链接");
}
static关键字:静态方法，可以带方法体；(通过 类名.静态方法名调用）静态方法不可以在实现类中重写，可以通过 接口名.静态方法调用；
static void stop（）{    
    System.out.println("我是接口中的静态方法");
}
接口中默认方法可以在实现类中重写，并可以通过接口的引用调用；
接口默认方法的调用：-  接口名.super.默认方法；
```

##### 关于多接口中重名默认方法处理

```java
1.一个类可以在继承父类的同时实现多个接口，具体格式是先继承父类然后实现多个接口，多个接口用逗号隔开。如
public class Son extends Father implements ISwim,IFly{}

2.一个类也可以不继承父类只同时实现多个接口，如
public class Son implements ISwim,IFly{}

2.如果一个类实现多个接口时，多个接口中存在某个方法名相同的情况，则必须在该子类中重写该方法以避免冲突。当子类对象调用该方法时，会调用子类重写的那个方法

3.如果子类继承的父类和同时实现的多个接口类中都有同名方法，但子类没有重写该方法也不会编译报错，当子类对象调用该方法时，会调用父类的那个方法；如果子类重写该方法，当子类对象调用该方法时，会调用子类重写的那个方法       
```

##### 关于多接口中重名常量处理

```java
多接口重名常量:
实现类打印接口中重名常量时会报错,解决办法:在实现类中通过 接口名.常量名 的方式明确指定调用的是哪个接口中的常量.
多接口,父类重名常量:
实现类打印接口中重名常量时会报错,解决办法:在实现类中自己写个重名的常量,测试类调用时,调用的就是实现类中的重名常量       
```

##### 接口的继承

```java
1. 接口也可以实现继承关系，并且可以继承多个父接口，使用extends关键字。
如public interface ISon extends IFather1,IFather2{}

2. 子接口的多个父接口中存在方法重名时的情况：
（1）若子接口的多个父接口中有重名的抽象方法，并不会产生冲突，因为都没有方法体。
（2）若子接口的多个父接口中有重名的静态方法，并不会产生冲突，因为静态方法无法被子接口继承；
（3）若子接口的多个父接口中有重名的默认方法，会产生冲突，必须要在子接口中写一个重名的默认方法。

3. 若一个子接口有多个父接口，则此子接口的实现类必须实现此接口及其父接口中的所有抽象方法。

（1）子类可以继承父类的静态方法与静态成员，但是无法构成重写关系，可以通过"子类对象.静态方法()"和"子类对象.静态成员"来调用；

（2）实现类或子接口可以继承父接口的静态常量，并通过“实现类对象.静态常量”或“子接口引用.静态常量”来调用父接口中的静态常量；

（3）但实现类或子接口无法继承父接口的静态方法，因而完全无法通过实现类对象和子接口引用来调用父接口的静态方法，会编译报错。       
```

#### 内部类

##### 概述

```java
1. 在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。与之对应，包含内部类的类被称为外部类。
2. 内部类隐藏在外部类之内，更好的实现了信息隐藏。
3. 在Java中内部类主要分为：成员内部类、静态内部类、方法内部类、匿名内部类。 
```

##### 成员内部类

```java
成员内部类：
成员内部类是最常见的内部类种类，也称为普通内部类

1、内部类在外部使用时，无法直接实例化，需要借由外部类信息实例化。

	Person lili=new Person();
	lili.age=12;
    //获取内部类对象实例，方式1：new 外部类().new 内部类()
    Person.Heart myHeart=new Person().new Heart();
    System.out.println(myHeart.beat());
	
	//方式2：外部类对象.new 内部类
	myHeart=lili.new Heart();
	System.out.println(myHeart.beat());
	
	//方式3:在外部类中定义方法，返回值是内部类的空间
	myHeart=lili.getHeart();
	System.out.println(myHeart.beat());

2、成员内部类可以调用外部类的所有属性，和方法
3、通过方式1 产生的对象无法获得外部类属性在主方法中重新赋值过的值
4、内部类的访问修饰符可以任意，但是范围会收到影响
5、如果同名，内部类优先调用内部类本身的属性和方法
6、可以使用 外部类.this.成员 的方式，访问外部类中同名的信息
7、外部类中如果想要调用内部类的属性，需要通过内部类实例。还可以用内部类来引用   new Heart（）.age=10；
8、内部类编译后.class文件命名：外部类&内部类.class
9、成员内部类可以可以包含与外部类相同方法签名的方法。 
如果同名，内部类优先调用内部类本身的属性和方法
 如果需要调用外部类的同名方法，可以和或外部类的变量一样：
 外部类.this.方法名的方式 -->   Preson.this.eat();
或 new 外部类().eat()；  
```

##### 静态内部类

```java
* 1、静态内部类中，只能直接访问外部类的静态成员，如果需要调用非静态方法，可以通过对象实例
* 2、静态内部类对象实例时，可以不依赖于外部类对象
* 3、可以通过外部类.内部类.静态成员访问类中的静态成员。
* 4、当内部类属性于外部类属性同名的时候，默认直接调用内部类中的成员；
* 5、如果需要访问外部类当中的的静态属性，则可以通过  
     外部类.属性 的方式；
* 6、如果需要访问外部类当中的的非静态属性，则可以通过  
     new 外部类().属性 的方式访问；       
```

##### 方法内部类

```java
定义在外部类非静态方法或静态方法中的内部类，也称局部内部类。
方法内部类使用时注意事项（无论是静态方法中还是非静态方法中都一样）：
1、定义在方法内部，作用范围也在方法内
2、和方法内部使用成员规则一样，class前面不可以添加public、private、protected、static，只能有final或abstract
3、类中不能包含静态成员
4、类中可以包含final、abstract(不推荐)修饰的成员      
```

##### 匿名内部类

```java
匿名内部类(上)
1.在程序设计中，有些类只会被实例化一次，给该类命名没有必要，且可以将类的定义与类的创建放到一起完成，以简化代码。这就是匿名内部类的由来。

2.适用场景：只用到类的一个实例，类在定义后马上用到，给类命名不会导致代码更容易被理解

3.具体格式见截图中方案3部分，其中的Person类为一抽象类，read为它的抽象方法

优点：内存消耗小,提升系统性能。
缺点：重复调用不方便, 如果想多次调用，则需要再写多次。

问题：匿名内部类是不是相应类或接口的子类或实现类？
解答：匿名内部类可以是普通类的子类、抽象类的子类、接口的实现类；但是匿名内部类无法同时继承父类和实现多个接口。 
    
匿名内部类(下)
1.匿名内部类没有类型名称、实列对象名称
2.编译后的文件命名：外部类$数字.class
3.无法使用private、public、protected、abstract、static修饰
4.无法编写构造方法,可以添加构造海马块
5.不能出现静态成员
6.匿名内部类可以实现接口也可以继承父类，但是不可兼得
```